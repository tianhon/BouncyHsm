using BouncyHsm.Core.Rpc;
using BouncyHsm.Core.Services.Contracts;
using BouncyHsm.Core.Services.Contracts.Entities;
using BouncyHsm.Core.Services.Contracts.P11;
using Microsoft.Extensions.Logging;
using Org.BouncyCastle.Crypto;
using Org.BouncyCastle.Crypto.Parameters;
using Org.BouncyCastle.Crypto.Signers;
using Org.BouncyCastle.Security;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace BouncyHsm.Core.Services.P11Handlers.Common;

internal class MlDsaWrapperSigner : IWrapperSigner
{
    private readonly Ckp_CkSignAdditionalContext? mechanismParams;
    private readonly ILogger<MlDsaWrapperSigner> logger;

    public MlDsaWrapperSigner(Ckp_CkSignAdditionalContext? mechanismParams, ILogger<MlDsaWrapperSigner> logger)
    {
        this.mechanismParams = mechanismParams;
        this.logger = logger;
    }

    public AuthenticatedSigner IntoSigningSigner(KeyObject keyObject, SecureRandom secureRandom)
    {
        this.logger.LogTrace("Entering to IntoSigningSigner.");

        if (keyObject is MlDsaPrivateKeyObject mlDsaPrivateKeyObject)
        {
            if (!mlDsaPrivateKeyObject.CkaSign)
            {
                this.logger.LogError("Object with id {ObjectId} can not set CKA_SIGN to true.", mlDsaPrivateKeyObject.Id);
                throw new RpcPkcs11Exception(CKR.CKR_KEY_FUNCTION_NOT_PERMITTED,
                    "The signature operation is not allowed because objet is not authorized to sign (CKA_SIGN must by true).");
            }

            MLDsaParameters parameters = MlDsaUtils.GetParametersFromType(mlDsaPrivateKeyObject.CkaParameterSet);
            bool isDeterministic = this.IsDeterministicRequired();
            MLDsaSigner signer = new MLDsaSigner(parameters, isDeterministic);

            ICipherParameters cipherParameters = mlDsaPrivateKeyObject.GetPrivateKey();
            if (!isDeterministic)
            {
                cipherParameters = new ParametersWithRandom(cipherParameters, secureRandom);
                this.logger.LogDebug("Using non-deterministic ML-DSA signer.");
            }

            if (this.mechanismParams?.Context != null)
            {
                cipherParameters = new ParametersWithContext(cipherParameters,
                    this.mechanismParams.Context);
                this.logger.LogDebug("Using additional context for ML-DSA signer.");
            }

            signer.Init(true, cipherParameters);

            return new AuthenticatedSigner(signer, mlDsaPrivateKeyObject.CkaAlwaysAuthenticate);
        }
        else
        {
            throw new RpcPkcs11Exception(CKR.CKR_KEY_HANDLE_INVALID, $"Mechanism {CKM.CKM_ML_DSA} required private RSA key.");
        }
    }

    public ISigner IntoValidationSigner(KeyObject keyObject)
    {
        this.logger.LogTrace("Entering to IntoValidationSigner.");

        if (keyObject is MlDsaPublicKeyObject mlDsaPublickeyObject)
        {
            if (!mlDsaPublickeyObject.CkaVerify)
            {
                this.logger.LogError("Object with id {ObjectId} can not set CKA_VERIFY to true.", mlDsaPublickeyObject.Id);
                throw new RpcPkcs11Exception(CKR.CKR_KEY_FUNCTION_NOT_PERMITTED,
                    "The verification signature operation is not allowed because objet is not authorized to verify (CKA_VERIFY must by true).");
            }

            MLDsaParameters parameters = MlDsaUtils.GetParametersFromType(mlDsaPublickeyObject.CkaParameterSet);
            MLDsaSigner signer = new MLDsaSigner(parameters, this.IsDeterministicRequired());

            if (this.mechanismParams?.Context != null)
            {
                signer.Init(false, new ParametersWithContext(mlDsaPublickeyObject.GetPublicKey(),
                    this.mechanismParams.Context));
            }
            else
            {
                signer.Init(false, mlDsaPublickeyObject.GetPublicKey());
            }

            return signer;
        }
        else
        {
            throw new RpcPkcs11Exception(CKR.CKR_KEY_HANDLE_INVALID, $"Mechanism {CKM.CKM_ML_DSA} required public RSA key.");
        }
    }

    private bool IsDeterministicRequired()
    {
        const bool DefaultHedgeVariant = false;

        if (this.mechanismParams is null)
        {
            return DefaultHedgeVariant;
        }

        return ((CK_HEDGE_TYPE)this.mechanismParams.HedgeVariant) switch
        {
            CK_HEDGE_TYPE.CKH_DETERMINISTIC_REQUIRED => true,
            CK_HEDGE_TYPE.CKH_HEDGE_PREFERRED => DefaultHedgeVariant,
            CK_HEDGE_TYPE.CKH_HEDGE_REQUIRED => false,
            _ => throw new InvalidProgramException($"Enum value {this.mechanismParams.HedgeVariant} is not supported.")
        };
    }
}
